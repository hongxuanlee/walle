var Engine = require("../lib/engine/engine.js");
var fs = require("fs");
var path = require("path");
var assert = require("assert");

describe("test engine", function() {
	it('should get compiled source', function() {
		var engine = Engine.create();
		var source = fs.readFileSync(path.join(__dirname, "./testTmpl/test7.tmpl"), "utf-8");
		var target = engine.compile(source);
		fs.writeFileSync(path.join(__dirname, "./result/test2.js"), target, "utf-8");
	});

	it('should run with data', function() {
		var engine = Engine.create();
		var source = fs.readFileSync(path.join(__dirname, "./testTmpl/test7.tmpl"), "utf-8");
		var target = engine.compile(source);

		fs.writeFileSync(path.join(__dirname, "./result/test4.js"), target, "utf-8");

		var template = null;
		eval("template = " + target);
		var str = template.run({
			data: {
				name: "ddchen",
				jump: "you jump, i jump!"
			}
		});
		assert.equal(true, str.search("ddchen") !== -1);
		assert.equal(true, str.search("you jump, i jump!") !== -1);
	});

	it('should work with collect', function() {
		var _left = "<#";
		var _right = "#>";
		var engine = Engine.create({
			tokenGrammers: [{
				leftDelimiter: _left + "\\s*script(?=(" + _right + ")|\\s)",
				wordReg: ".*?",
				rightDelimiter: _right,
				type: "script",
				block: {
					type: "start"
				},
				processor: ["attributeCode", "attributeMap"]
			}, {
				leftDelimiter: _left + "\\s*/script(?=(" + _right + ")|\\s)",
				wordReg: ".*?",
				rightDelimiter: _right,
				type: "script",
				block: {
					type: "end"
				}
			}, {
				leftDelimiter: _left + "\\s*body(?=(" + _right + ")|\\s)",
				wordReg: ".*?",
				rightDelimiter: _right,
				type: "body",
				block: {
					type: "start"
				},
				processor: ["attributeCode", "attributeMap"]
			}, {
				leftDelimiter: _left + "\\s*/body(?=(" + _right + ")|\\s)",
				wordReg: ".*?",
				rightDelimiter: _right,
				type: "body",
				block: {
					type: "end"
				}
			}],
			interpreterPluginMap: {
				"script": function(token, childCodes) {
					this.addGlobalCode("lemur.collect('res-script',function(){" + childCodes + "});");
				},
				"body": function(token, childCodes) {
					return "lemur.echo('<body>');lemur.echo('<script>');lemur.runRes('res-script');lemur.echo('</script>');lemur.echo('</body>');";
				}
			}
		});
		var source = fs.readFileSync(path.join(__dirname, "./testTmpl/test8.tmpl"), "utf-8");
		var target = engine.compile(source);
		fs.writeFileSync(path.join(__dirname, "./result/test3.js"), target, "utf-8");

		var template = null;
		eval("template = " + target);
		template.run();
		var str = template.run();
		console.log(str);
		assert.equal(true, str.search('what') != -1);
		assert.equal(true, str.search('res') != -1);
		console.log(template.extract('res-script'));

		var resStr = template.extract('res-script');
		assert.equal(true, resStr.search('what') != -1);
		assert.equal(true, resStr.search('res') != -1);
	});
});